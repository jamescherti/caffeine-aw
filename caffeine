#!/usr/bin/env python3
#
# Copyright Â© 2009-2022 The Caffeine-aw Developers
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import argparse
import fcntl
import gc
import logging
import os
import shutil
import signal
import sys
import time
from subprocess import call

import pkg_resources  # type: ignore
from ewmh import EWMH
from setproctitle import setproctitle


PROGRAM_NAME = "caffeine"
XDG_SCREENSAVER_CMD = "xdg-screensaver"


class SingleInstance:
    def __init__(self, lockfile):
        self.lockfile = lockfile
        self.another_instance_running = False

        try:
            self.filed = open(self.lockfile, 'wb')
        except OSError as err:
            print(f"Error: {err}.", file=sys.stderr)
            sys.exit(1)

        try:
            fcntl.lockf(self.filed, fcntl.LOCK_EX | fcntl.LOCK_NB)
        except IOError:
            self.another_instance_running = True

        if self.another_instance_running:
            print(f"Error: another instance of '{PROGRAM_NAME}' is running "
                  f"(lock file: '{lockfile}').",
                  file=sys.stderr)
            sys.exit(1)

    def delete_lockfile(self):
        if hasattr(self, 'filed') and self.filed:
            if not self.another_instance_running:
                fcntl.lockf(self.filed, fcntl.LOCK_UN)

            self.filed.close()
            self.filed = None

            if self.lockfile and not self.another_instance_running:
                logging.debug("Delete: %s", self.lockfile)
                try:
                    os.unlink(self.lockfile)
                except OSError:
                    pass

                self.lockfile = None

    def __del__(self):
        self.delete_lockfile()


class Caffeine:
    def __init__(self):
        self.ewmh = EWMH()
        self.windows_inhibited = set()
        self.windows_normal = {}
        self.windows_fullscreen = {}

    def main(self):
        while True:
            self._check_for_fullscreen_all_windows()
            # 30s: same interval as mplayer's heartbeat command
            time.sleep(30)

    def _check_for_fullscreen_all_windows(self):
        list_win = self.ewmh.getClientList()

        # Find full-screen windows
        self.windows_fullscreen = {}
        self.windows_normal = {}
        for win in list_win:
            hex_win_id = hex(win.id)

            try:
                wm_state = self.ewmh.getWmState(win, str=True)
                if '_NET_WM_STATE_FULLSCREEN' in wm_state:
                    self.windows_fullscreen[hex_win_id] = (win, wm_state)
                else:
                    self.windows_normal[hex_win_id] = (win, wm_state)
            # pylint: disable=broad-except
            except Exception:
                pass

        # Suspend windows
        inhibited_win = set()
        for hex_win_id in self.windows_fullscreen:
            if hex_win_id in self.windows_inhibited:
                continue

            call([XDG_SCREENSAVER_CMD, 'suspend', hex_win_id])
            inhibited_win.add(hex_win_id)

        for hex_win_id in inhibited_win:
            logging.info(
                "The window %s is now inhibiting desktop idleness",
                hex_win_id,
            )

        # Resume
        self.windows_inhibited = self.windows_inhibited | inhibited_win
        self.release()

        # Return True so timeout is rerun
        return True

    def release(self, force=False):
        if not self.windows_inhibited:
            return

        all_windows = self.windows_normal | self.windows_fullscreen

        resumed_win_id = set()
        for hex_win_id in self.windows_inhibited:
            if not force and hex_win_id in all_windows and \
                    hex_win_id not in self.windows_normal:
                continue

            if hex_win_id in all_windows:
                call([XDG_SCREENSAVER_CMD, 'resume', hex_win_id])

            resumed_win_id.add(hex_win_id)

        self.windows_inhibited -= resumed_win_id

        if resumed_win_id:
            for hex_win_id in resumed_win_id:
                logging.info(
                    "The window %s is no longer inhibiting desktop idleness",
                    hex_win_id,
                )


# pylint: disable=unused-argument
def run_garbage_collector(signum, frame):
    """Run the garbage collector."""
    gc.collect()
    sys.exit(1)


def parse_args():
    parser = argparse.ArgumentParser(
        prog=PROGRAM_NAME,
        description='Prevent desktop idleness in full-screen mode',
    )
    parser.add_argument(
        '-V', '--version', action='version',
        version=(PROGRAM_NAME + ' ' +
                 pkg_resources.require("caffeine-aw")[0].version)
    )
    parser.parse_args()
    return parser


def main():
    """The command-line interface."""
    logging.basicConfig(
        level=logging.DEBUG,
        stream=sys.stdout,
        format="[" + PROGRAM_NAME + "] %(message)s",
    )

    setproctitle(PROGRAM_NAME)

    for sig in (signal.SIGINT, signal.SIGTERM, signal.SIGHUP):
        signal.signal(sig, run_garbage_collector)

    if not shutil.which(XDG_SCREENSAVER_CMD):
        logging.error("Error: '%s': command not found", XDG_SCREENSAVER_CMD)
        sys.exit(1)

    parse_args()

    # Single instance
    lockfile = os.path.expanduser("~/.caffeine-aw.lock")

    single_instance = SingleInstance(lockfile=lockfile)

    caffeine = Caffeine()
    logging.info("%s has started.", PROGRAM_NAME)

    try:
        caffeine.main()
    except KeyboardInterrupt:
        pass
    finally:
        single_instance.delete_lockfile()
        caffeine.release(force=True)
        logging.info("%s has stopped.", PROGRAM_NAME)


if __name__ == '__main__':
    main()
